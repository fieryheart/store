# 动态规划

## 背包问题
话说有一哥们去森林里玩发现了一堆宝石，他数了数，一共有n个。 但他身上能装宝石的就只有一个背包，背包的容量为C。这哥们把n个宝石排成一排并编上号： 0,1,2,…,n-1。第i个宝石对应的体积和价值分别为V[i]和W[i]  

+ V[0]表示第一个宝石的价值,W[0]表示第一个宝石的重量
+ 状态maxValue(i, j)表示前i个宝石装到剩余体积为j的背包里能达到的最大价值
> 比如 maxValue(3, 10) 表示的是前3个宝石装入到剩余体积为10的背包里达到的最大价值，既然是最大价值，就有maxValue(3, 10) = max{ maxValue(2, 10), maxValue(2, 7)+V[2] }, 之后程序再考虑 maxValue(2, 7) = max{ maxValue(1, 7), maxValue(1, 3)+ V[1]}, 于是就变成比较V[0]和V[1]哪个更有价值了  

```
  //核心算法
  var maxValue;//最大价值
  for(let i = 0; i <= n; i++){
    for(let j = 0; j <= C; j++){
      maxValue[i][j] = i===0 ? 0 : maxValue[i-1][j];
      if(i > 0 && j >= V[i-1]){
        maxValue[i][j] = maxValue[i][j] > (maxValue[i-1][j-V[i-1]] + W[i-1]) ? maxValue[i][j] :
        (maxValue[i-1][j-V[i-1]] + W[i-1]);
      }
    }
  }
```

## 查找最长回文串问题

```
  //先将字符串"abaab"(str)变成'#a#b#a#a#b#'(newstr)
  // maxid是newstr的0位置开始到以当前字符为中心的最长回文串的尾部的长度
  // p[i]表示已每个字符为中点的回文串半径

  for(let i = 0 ; i < len; i++){
    if(maxid > 1){
      //如果最长的回文字符串的长度大于1，就取当前字符串为中心的回文串的长度为 p[2*id - i] 和 maxid - i 中的最小值
      //因为回文串的对称性可知,当前的p[i] >= p[id*2 - i](以newstr[id]为中心对称的字符为中心的最长回文串半径)
      //即以newstr[2*id - 1]为字符中心的回文串的半径大于maxid-i时，回文串的对称性使得p[i] === p[id*2-i]的条件就不满足了，而以newstr[i]为中心的回文串根据回文串的对称性最大的上限为maxid-i
      p[i] = min(p[2*id - i], maxid - i);
    }else{
      //如果最长的回文串的长度小于1, 那么此时以当前字符为中心的回文字符串的长度就为1
      p[i] = 1;
    }

    //从p[i]开始如果还相同的话就增加当前回文串的半径长度
    while(newstr[i+p[i]] === newstr[i-p[i]]){
      p[i]++;
    }

    //如果从newstr的0位置开始到以当前字符为中心的最长回文串的尾部的长度大于之前的长度，那么就赋值给这个最长的长度
    if(p[i] + i > maxid){
      maxid = p[i] + i;
      //将这个定位点赋给id，让人知道这个字符有最长的回文串
      id = i;
    }

    if(ans < p[i]){
      //回文字符串的最长的长度
      ans = p[i];
    }
  }
```
谈谈对动态规划的理解，借助之前的经验对后面的问题进行解答，感觉和递归在思维上有相通点但是没有共同点，动态规划是以相同的有选择性的条件来依次解决一个一个问题
