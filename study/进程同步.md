# 进程同步

下面的叙述将 线程 == 进程 来讲解

## 为什么会出现“锁”
因为在线程同步的过程中会出现多个线程同时使用同一块内存进行一些互斥的操作，  
所以出现了“锁”, “锁”让一个线程使用这块内存时将其锁住，不让其他进程使用这块  
内存。

## 为什么会出现“睡觉”与“叫醒”
因为在其他进程不能使用这块内存时会进入**等待**状态, 占用CPU, 影响计算机效率,  
所以出现了“睡觉”，让其他进程进入**休眠**状态, 其所占用的CPU被释放, 而“睡觉”肯  
定需要被“叫醒”

## “睡觉”和“叫醒”过程发生死锁
(  
假定现有两个线程分别为线程A和线程B,  
“睡觉”操作为`sleep()`,  
“叫醒”操作为`wakeup()`,  
设一个判定条件,  
当`count == 0`时, 线程A`wakeup()`, 线程B`sleep()`;  
当`count == 1`时, 线程A`sleep()`, 线程B`wakeup()`;  
线程A执行`wakeup()`造成`count++`;  
线程B执行`wakeup()`造成`count--`;    
)  
执行过程分为判定count和执行`sleep()`或`wakeup()`

开始执行...
1. 线程B进入, 判定count(此时`count==0`), 线程B将要执行`sleep()`
2. 线程A进入, 判定count(此时`count==0`), 线程A将要执行`wakeup()`
3. 线程A执行`wakeup()`, 此时`count == 1`
4. 线程B执行`sleep()`
5. 线程A判定count(此时`count==1`), 将要执行`sleep()`
6. 线程A执行`sleep()`
7. count无法变为0, 线程A和线程B都进入休眠, 出现死锁

上述死锁的情况描述错误

## 为什么会出现信号量
因为在“睡觉”和“叫醒”的过程中会出现死锁的情况, 而死锁的情况的原因是线程A执行`wakeup()`  
放在判定count的过程和线程B执行`sleep()`的过程之间  
所以提出信号量让线程A不会插入线程B的sleep()
