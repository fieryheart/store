# 进程同步

下面的叙述将 线程 == 进程 来讲解

## 为什么会出现“锁”
因为在线程同步的过程中会出现多个线程同时使用同一块内存进行一些互斥的操作，  
所以出现了“锁”, “锁”让一个线程使用这块内存时将其锁住，不让其他进程使用这块  
内存。

## 为什么会出现“睡觉”与“叫醒”
因为在其他进程不能使用这块内存时会进入**等待**状态, 占用CPU, 影响计算机效率,  
所以出现了“睡觉”，让其他进程进入**休眠**状态, 其所占用的CPU被释放, 而“睡觉”肯  
定需要被“叫醒”

## “睡觉”和“叫醒”过程发生死锁
(  
假定现有两个线程分别为线程A和线程B,  
“睡觉”操作为`sleep()`,  
“叫醒”操作为`wakeup()`,  
设一个判定条件,  
当`count == 0`时, 线程B向线程A发出“叫醒”信号, 线程B执行`sleep()`;  
当`count == 1`时, 线程A向线程B发出“叫醒”信号, 一直到缓冲区被填满了,线程A执行`sleep()`;  
线程A每运行一次造成`count++`, 缓冲区内存使用量+1;  
线程B每运行一次造成`count--`, 缓冲区内存使用量-1;    
)  

开始执行...
+ CPU转移给线程B, 判定count(此时`count==0`), 线程B向线程A发出“叫醒”信号, 线程B将要执行`sleep()`
+ CPU转移给线程A, 判定count(此时`count==0`), 线程A将要执行`wakeup()`
+ 线程A`wakeup()`
+ 线程A执行一次, `count == 1`, 向线程B发出“叫醒”信号
+ 线程B此时处于将要`sleep()`阶段, “叫醒”信号被忽略
+ 线程A再执行一次, `count == 2`
+ 线程A再执行一次, `count == 3`、

一直到缓冲区被填满。。。。。。

+ 线程A执行`sleep()`
+ 线程B执行`sleep()`
+ 线程A和线程B都进入休眠, 两个线程都无法往前推进, 出现死锁

## 为什么出现信号量
因为在“睡觉”和“叫醒”的过程中会出现死锁的情况, 出现死锁的原因是线程A向线程B发出的“叫醒”信号丢失了, 为了不让其丢失, 就需要积累这些信号  
而积累这些信号的行为叫做信号量  
信号量是一个操作系统原语  
> 操作系统原语是由若干个机器指令构成的完成某种特定功能的一段程序，具有不可分割性·即原语的执行必须是连续的，在执行过程中不允许被中断
